
<!DOCTYPE html>
<html lang class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RainBow</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="Ａ*寻路算法A*搜索算法，俗称Ａ星算法，作为启发式搜错算法中的一种，这是一种在图形平面上，有多个节点路径，求出最低通过成本的算法．长用于游戏中的NPC的移动计算，或线上游戏BOT的移动计算上．该算法,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="RainBow" type="application/atom+xml"> 
    <link rel="icon" href="/img/rainbowico.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">图像处理基础算法</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">图像处理基础算法</h1>
        <div class="stuff">
            <span>三月 19, 2019</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/算法/">算法</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="Opencv的Mat数据转换"><a href="#Opencv的Mat数据转换" class="headerlink" title="Opencv的Mat数据转换"></a>Opencv的Mat数据转换</h2><ul>
<li style="list-style: none"><input type="checkbox" checked> Mat -&gt; Vector</li>
<li style="list-style: none"><input type="checkbox" checked> vector -&gt; Mat</li>
<li style="list-style: none"><input type="checkbox" checked> uchar[] -&gt; Mat</li>
<li style="list-style: none"><input type="checkbox" checked> Mat -&gt; uchar[]</li>
</ul>
<h3 id="Mat-gt-Vector"><a href="#Mat-gt-Vector" class="headerlink" title="Mat -&gt; Vector"></a>Mat -&gt; Vector</h3><p>要将mat转换为vector可以借助opencv<a href="https://docs.opencv.org/master/d3/d63/classcv_1_1Mat.html#a4eb96e3251417fa88b78e2abd6cfd7d8" target="_blank" rel="noopener">官方API</a>将图像转换为行存入vector中．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat cv::Mat::reshape(int cn, int rows = 0) cons</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>功能:<br>       在不复制数据的情况下更改二维矩阵的形状和通道数目．<br>参数:<br>       <code>cn</code> 新的通道数，如果参数为0，则通道数保持不变．<br>       <code>rows</code> 新的行数，如果参数为0，则通道数保持不变.       </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp&gt;</span><br><span class="line">vector&lt;_Tp&gt; Mat2vector(const Mat &amp;mat)</span><br><span class="line">&#123;</span><br><span class="line">	return (vector&lt;_Tp&gt;)(mat.reshape(1, 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="vector-gt-Mat"><a href="#vector-gt-Mat" class="headerlink" title="vector -&gt; Mat"></a>vector -&gt; Mat</h3><p><a href="https://docs.opencv.org/master/d3/d63/classcv_1_1Mat.html#a23b182c4ffd46abe38f460c1480ae887" target="_blank" rel="noopener">Mat构造函数</a>可以将vector转换为一维Mat，之后可以使用上述的Mat::reshape将一维度数组转换成二维图像数组．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat::Mat(const std::vector&lt; _Tp &gt;　&amp;vec,bool　copyData = false)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>功能:<br>       根据vector向量生成Mat,生成的Mat有一列，行数和元素个数相同.<br>参数:<br>       <code>vec</code> vector类型的向量<br>       <code>copyData</code> (true)是否将vector中的数据复制，(false)或与vector共享数据.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp&gt;</span><br><span class="line">cv::Mat vector2Mat(vector&lt;_Tp&gt; vec, int channels, int rows)</span><br><span class="line">&#123;</span><br><span class="line">	cv::Mat mat = cv::Mat(v, ture);</span><br><span class="line">	//必须拷贝一份，否则会出错(多行一列)</span><br><span class="line">	cv::Mat dst = mat.reshape(channels, rows).clone;</span><br><span class="line">	return dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组-gt-Mat"><a href="#数组-gt-Mat" class="headerlink" title="数组-&gt;Mat"></a>数组-&gt;Mat</h3><p>可以使用<a href="https://docs.opencv.org/master/d3/d63/classcv_1_1Mat.html#a5fafc033e089143062fd31015b5d0f40" target="_blank" rel="noopener">Mat的构造函数</a>将数组转换为Mat类型.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat::Mat(Size size,　int type,　void * data,　size_t step = AUTO_STEP)</span><br><span class="line">cv::Mat::Mat(int rows, int cols, int type, void* data, size_t setp =AUTO_STEP)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>功能:<br>       将数组转化为Mat<br>形参:<br>       <code>rows</code>  图像的行数<br>       <code>cols</code>  图像的列数<br>       <code>size</code>　图像的尺寸<br>       <code>type</code>　图像的类新 CV_8UC\CV_32FC1<br>       <code>*data</code> 图像数据<br>       <code>step</code>  每个矩阵行所占的字节数     </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat array2Mat(void* array, int rows, int cols, int type)</span><br><span class="line">&#123;</span><br><span class="line">	cv::Mat dst(rows, cols, type, (void*)array)</span><br><span class="line">	return dst.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mat-gt-数组"><a href="#Mat-gt-数组" class="headerlink" title="Mat-&gt;数组"></a>Mat-&gt;数组</h3><p>对于连续的数组可以使用Mat::data()函数取出图像数据．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class _Tp&gt;</span><br><span class="line">_Tp* Mat2array(const Mat &amp;mat)</span><br><span class="line">&#123;</span><br><span class="line">	_Tp *array = new _Tp[mat.total()];</span><br><span class="line">	if(mat.isContinuous())&#123;</span><br><span class="line">	array = mat.data;</span><br><span class="line">	&#125;</span><br><span class="line">	return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="图像缩放"><a href="#图像缩放" class="headerlink" title="图像缩放"></a>图像缩放</h2><p>&emsp;&emsp;图像缩放算法往往基于插值实现，常见的图像插值方法包括最近邻插值(Nearest-neighbor)丶双线性插值(Bilinear)丶双立方插值(bicubic)丶方向插值(Edge-directed interpolation)丶基于深度学习等算法．<a href="https://blog.csdn.net/M_Z_G_Y/article/details/80378348" target="_blank" rel="noopener">公式推导</a><br><img src="/img/图像处理算法/基础/1.jpg" alt="图像插值"></p>
<h3 id="最近邻插值"><a href="#最近邻插值" class="headerlink" title="最近邻插值"></a>最近邻插值</h3><p>最近邻插值是采取采样点周围四个相邻像素中距离最近的一个点的灰度值作为该点的灰度值的方法.Ｉ</p>
<p><div align="center"><img src="/img/图像处理算法/基础/15.png" alt="最近邻插值"></div></p>
<p>优点:<br>&emsp;&emsp;简单快速，灰度保真较好．<br>缺点:<br>&emsp;&emsp;会产生明显的锯齿和马赛克，视觉特性较差．<br>公式:</p>
<p><div align="center"><img src="/img/图像处理算法/基础/10.png" alt="欧氏距离"></div></p>
<blockquote>
<p>引入0.5是为了让原图像与目标图像几何中心对齐．</p>
</blockquote>
<h4 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h4><p>如下图所示，P为目标图像中对应到原始图像中的点(亚像素)，Q11丶Q12丶Q21丶Q22是P点周围的四个整数点,可以根据距离度量公式(De欧氏距离丶D4城市街区距离丶D8棋盘<br>距离)<br>欧氏距离De:<font color="#008000"> － </font>  城市距离D4:<font color="#00FFFF"> <strong>－</strong> </font> <font color="#FFD700"> <strong>－</strong> </font> <font color="#FF0000"> <strong>－</strong> </font>   </p>
<p><img src="/img/图像处理算法/基础/8.png" width="300" height="300" div aligni="center"></p>
<ol>
<li><p>欧几里德距离<br>欧几里德距离简称欧氏距离，也就是我们通常所说的亮点之间的直线距离.<br><div align="center"><img src="/img/图像处理算法/基础/5.png" alt="欧氏距离"> </div></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double distance_euclid(double x0, double y0, double x1, double y1)</span><br><span class="line">&#123;</span><br><span class="line">  double distance = sqrt(pow((x0 - x1), 2)+ pow((y0 - y1), 2));</span><br><span class="line">  return distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>城市距离(曼哈顿距离)<br>出租车几何或曼哈顿距离，用以表明两个点在基准坐标系下绝对轴距之和.<br><div align="center"><img src="/img/图像处理算法/基础/6.png" alt="曼哈顿距离"></div></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double distance_manhattan(double x0, double y0, double x1, double y1)</span><br><span class="line">&#123;</span><br><span class="line">  double distance = fabs(x0 - x1)+fabs(y0 - y1);</span><br><span class="line">  return distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>棋盘距离(切比雪夫距离)<br>在国际棋盘上，王从一点到另一点的距离<br><div align="center"><img src="/img/图像处理算法/基础/7.png" alt="棋盘距离"></div></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void distance_checkerboard(double x0, double y0, double x1, double y1)</span><br><span class="line">&#123;</span><br><span class="line">  double distance = fabs(x0 - x1) &gt; fabs(y0 - y1)?fabs(x0 - x1):fabs(y0 - y1);</span><br><span class="line">  return distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>为了简单直观，这里直接使用但通道图像做演示．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 函数功能:使用最近邻插值方法缩放图像</span><br><span class="line">* 参数:</span><br><span class="line">*      input_image - 输入图像(单色图像)</span><br><span class="line">*      output_image - 输出图像</span><br><span class="line">*      size -输出图像大小(像素)</span><br><span class="line">*      distance_type - 计算距离方法 0 欧式距离 1 曼哈顿距离 2 切比雪夫距离</span><br><span class="line">**/</span><br><span class="line">void nearestScaler(cv::Mat &amp;input_image, cv::Mat &amp;output_image, cv::Size size, int distance_type)</span><br><span class="line">&#123;</span><br><span class="line">  //拷贝输入图像</span><br><span class="line">  cv::Mat temp_image = input_image.clone();</span><br><span class="line">  output_image = cv::Mat(size, temp_image.type());</span><br><span class="line">  //计算缩放比例</span><br><span class="line">  double scale_row = static_cast&lt;double&gt;(temp_image.rows)/size.height;</span><br><span class="line">  double scale_col = static_cast&lt;double&gt;(temp_image.cols)/size.width;</span><br><span class="line">  //遍历图像</span><br><span class="line">  for(int rows = 0; rows &lt; size.height; rows++)&#123;</span><br><span class="line">    for(int cols = 0; cols &lt; size.width; cols++)&#123;</span><br><span class="line">      //计算缩放后原始图坐标</span><br><span class="line">      double x = (rows + 0.5) * scale_row + 0.5;</span><br><span class="line">      double y = (cols + 0.5) * scale_col + 0.5;</span><br><span class="line">      //找出坐标周围的四个点</span><br><span class="line">      int x0 = static_cast&lt;uint&gt;(x);</span><br><span class="line">      if(x0 &gt; temp_image.rows - 1) x0 = temp_image.rows - 1;</span><br><span class="line">      int x1 = x0 + 1;</span><br><span class="line">      int y0 = static_cast&lt;uint&gt;(y);</span><br><span class="line">      if(y0 &gt; temp_image.cols - 1) y0 = temp_image.cols - 1;</span><br><span class="line"></span><br><span class="line">      int y1 = y0 + 1;</span><br><span class="line">      //使用距离度量公式找出最小距离</span><br><span class="line">      std::vector&lt;double&gt;dist(4);</span><br><span class="line">      switch(distance_type)&#123;</span><br><span class="line">          case 0://欧氏距离</span><br><span class="line">            dist[0] = distance_euclid(x, y, x0, y0);</span><br><span class="line">            dist[1] = distance_euclid(x, y, x1, y0);</span><br><span class="line">            dist[2] = distance_euclid(x, y, x0, y1);</span><br><span class="line">            dist[3] = distance_euclid(x, y, x1, y1);</span><br><span class="line">            break;</span><br><span class="line">          case 1://曼哈顿距离</span><br><span class="line">            dist[0] = distance_manhattan(x, y, x0 ,y0);</span><br><span class="line">            dist[1] = distance_manhattan(x, y, x1 ,y0);</span><br><span class="line">            dist[2] = distance_manhattan(x, y, x0 ,y1);</span><br><span class="line">            dist[3] = distance_manhattan(x, y, x1 ,y1);</span><br><span class="line">            break;</span><br><span class="line">          case 2://棋盘距离</span><br><span class="line">            dist[0] = distance_checkerboard(x, y, x0, y0);</span><br><span class="line">            dist[1] = distance_checkerboard(x, y, x1, y0);</span><br><span class="line">            dist[2] = distance_checkerboard(x, y, x0, y1);</span><br><span class="line">            dist[3] = distance_checkerboard(x, y, x1, y1);</span><br><span class="line">            break;</span><br><span class="line">          default:</span><br><span class="line">            break;</span><br><span class="line">           &#125;</span><br><span class="line">          //找出最小距离对因的下标</span><br><span class="line">          auto smallest = min_element(std::begin(dist), std::end(dist));</span><br><span class="line">          int min_index = distance(std::begin(dist), smallest);</span><br><span class="line">          //图像插值</span><br><span class="line">          switch(min_index)&#123;</span><br><span class="line">            case 0:</span><br><span class="line">               output_image.at&lt;uchar&gt;(rows, cols) = temp_image.at&lt;uchar&gt;(x0, y0);</span><br><span class="line">               break;</span><br><span class="line">            case 1:</span><br><span class="line">               output_image.at&lt;uchar&gt;(rows, cols) = temp_image.at&lt;uchar&gt;(x1, y0);</span><br><span class="line">               break;</span><br><span class="line">            case 2:</span><br><span class="line">               output_image.at&lt;uchar&gt;(rows, cols) = temp_image.at&lt;uchar&gt;(x0, y1);</span><br><span class="line">               break;</span><br><span class="line">            case 3:</span><br><span class="line">               output_image.at&lt;uchar&gt;(rows, cols) = temp_image.at&lt;uchar&gt;(x1, y1);</span><br><span class="line">               break;</span><br><span class="line">            default:</span><br><span class="line">               break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>额外参考:<a href="https://blog.csdn.net/ccblogger/article/details/72918354" target="_blank" rel="noopener">https://blog.csdn.net/ccblogger/article/details/72918354</a></p>
<h3 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h3><p>双线性插值利用周围四个点的灰度值在两个方向上做线性插值得到采样点的灰度值．</p>
<p><div align="center"><img src="/img/图像处理算法/基础/16.png" alt="双线性插值"></div></p>
<p>优点:<br>&emsp;&emsp; 1. 计算中较为充分的考虑了相邻各个点的特征，具有灰度平滑过渡的特点．<br>&emsp;&emsp; 2. 一般情况下可以得到满意的结果</p>
<p>缺点:<br>&emsp;&emsp; 1. 具有地通滤波特性，使图像轮廓模糊<br>&emsp;&emsp; 2. 平滑做用使得图像细节退化，尤其在放大的时候尤为明显．</p>
<p>公式:</p>
<p><div align="center"><img src="/img/图像处理算法/基础/9.png" alt="双线性插值"></div></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 函数功能: 双线性插值缩放图像</span><br><span class="line"> * 参数:</span><br><span class="line"> *      input_image - 输入图像</span><br><span class="line"> *      output_image - 输出图像</span><br><span class="line"> *      size - 缩放尺寸</span><br><span class="line"> * 备注:</span><br><span class="line"> *      只能进行单通道图片缩放</span><br><span class="line"> **/</span><br><span class="line">void bilinearIntertpolatioin(cv::Mat &amp;input_image, cv::Mat &amp;output_image, cv::Size size)</span><br><span class="line">&#123;</span><br><span class="line">    cv::Mat temp_image = input_image.clone();</span><br><span class="line">    output_image = cv::Mat(size, temp_image.type());</span><br><span class="line"></span><br><span class="line">    //计算缩放比例</span><br><span class="line">    double scalar_rows = static_cast&lt;double&gt;(temp_image.rows) / size.height;</span><br><span class="line">    double scalar_cols = static_cast&lt;double&gt;(temp_image.cols) / size.width;</span><br><span class="line"></span><br><span class="line">    for(int rows = 0; rows &lt; size.height; rows++)&#123;</span><br><span class="line">        for(int cols = 0; cols &lt; size.width; cols++)&#123;</span><br><span class="line">           double x = (rows + 0.5) * scalar_rows - 0.5;</span><br><span class="line">           double y = (cols + 0.5) * scalar_cols - 0.5;</span><br><span class="line">           //防止超出图像边界</span><br><span class="line">           double x0 = static_cast&lt;uint&gt;(x);</span><br><span class="line">           x0 = x0 &lt; 0? 0:x0;</span><br><span class="line">           x0 = x0 &gt; (temp_image.rows - 1)? (temp_image.rows - 1) : x0;</span><br><span class="line">           double x1 = x0 + 1;</span><br><span class="line"></span><br><span class="line">           double y0 = static_cast&lt;uint&gt;(y);</span><br><span class="line">           y0 = y0 &lt; 0? 0 : y0;</span><br><span class="line">           y0 = y0 &gt; (temp_image.cols -1)? (temp_image.cols - 1) : y0;</span><br><span class="line">           double y1 = y0 + 1;</span><br><span class="line">           cv::Matx12d matx = &#123;x1 - x, x - x0&#125;;</span><br><span class="line">           cv::Matx22d matd = &#123;static_cast&lt;double&gt;(temp_image.at&lt;uchar&gt;(x0, y0)), static_cast&lt;double&gt;(temp_image.at&lt;uchar&gt;(x0, y1)),</span><br><span class="line">                               static_cast&lt;double&gt;(temp_image.at&lt;uchar&gt;(x1, y0)), static_cast&lt;double&gt;(temp_image.at&lt;uchar&gt;(x1,y1))&#125;;</span><br><span class="line">           cv::Matx21d maty = &#123;y1 - y,</span><br><span class="line">                               y - y0&#125;;</span><br><span class="line"></span><br><span class="line">            auto val = matx * matd * maty;</span><br><span class="line">            output_image.at&lt;uchar&gt;(rows, cols) = val(0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>static_cast<uchar>()只保留整数部分，小数部分被舍弃:<br><code>static_cast&lt;uchar&gt;(4.1)</code>结果为4<br><code>static_cast&lt;uchar&gt;(4.8)</code>结果也为4</uchar></p>
</blockquote>
<h3 id="双三次插值"><a href="#双三次插值" class="headerlink" title="双三次插值"></a>双三次插值</h3><p>双三次插值方法，(三次立方插值法或CC插值法)，是一种利用待插值点16个邻点像素值经过计算得到，没一个点需要经过５次计算，所以耗费时间长．</p>
<p><div align="center"><img src="/img/图像处理算法/基础/17.png" alt="双三次插值"></div></p>
<p>优点:<br>&emsp;&emsp; 1. 三次卷积内插法减少高频损失，可以有效的平滑噪声．<br>&emsp;&emsp; 2. 三次卷积内差法可以得到最佳结果(相比于上面两种插值方法)．</p>
<p>缺点:<br>&emsp;&emsp; 计算量大，所需时间长．</p>
<p>公式:</p>
<p><div align="center"><img src="/img/图像处理算法/基础/18.png" alt="二维高斯"> </div></p>
<h2 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Canny算子是<a href="http://www.cs.berkeley.edu/~jfc/" target="_blank" rel="noopener">John Canny</a>在1986年提出的一种边缘检测方法．Canny的目地就是找到一个最优的边缘检测算法，优的边缘检测含义是:</p>
<ol>
<li>最优检测:算法能够尽可能地多标识出图像中的实际边缘.　- <code>边缘全</code></li>
<li>检测到的便晕应精确的定位在真实边缘的中心． - <code>定位准确</code></li>
<li>途中给定的边缘只标记一次, 并且在可能的情况下，图像的噪声不产生假的边缘． - <code>抗噪声能力强</code><br>步骤:<br>&emsp;&emsp;高斯平滑滤波-&gt;计算梯度和方向-&gt;非极大值抑制-&gt;双阈值检测和连接边缘</li>
</ol>
<h3 id="Setp1-高斯平滑"><a href="#Setp1-高斯平滑" class="headerlink" title="Setp1: 高斯平滑"></a>Setp1: 高斯平滑</h3><h4 id="高斯核"><a href="#高斯核" class="headerlink" title="高斯核"></a>高斯核</h4><p>&emsp;&emsp;高斯模糊(Gaussian Blur)，也叫做高斯平滑，通常用它来减少噪声以及降低细节测层次.高斯模糊对于原图想来说是一个低通滤波器.<br>公式:</p>
<p><div align="center"><img src="/img/图像处理算法/基础/11.png" alt="二维高斯"> </div></p>
<blockquote>
<p>σ:标准差，其越大图像越模糊</p>
</blockquote>
<p>代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 功能: 求解高斯核</span><br><span class="line">* 参数:</span><br><span class="line">*      sigma - σ(标准差)</span><br><span class="line">*      size - 高斯矩阵大小(只能是奇数)</span><br><span class="line">**/</span><br><span class="line">//高斯卷积核生成</span><br><span class="line">void getOneGuassionArray(int size, double sigma, double **gauss)</span><br><span class="line">&#123;</span><br><span class="line">    double pi = 3.1415927;</span><br><span class="line">    int center = size/2;</span><br><span class="line">    double sum = 0.0;</span><br><span class="line">    for(int i = 0; i &lt; size; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; size; j++)&#123;</span><br><span class="line">        gauss[i][j] = exp(-(pow((i-center),2) + pow((j-center),2))/(2*pow(sigma,2))) / (2*pi*pow(sigma,2));</span><br><span class="line">        sum += gauss[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; size; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; size; j++)&#123;</span><br><span class="line">            gauss[i][j] = gauss[i][j] / sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果:<br>下面是σ = 0.5,size = 3所得到的高斯核</p>
<p><div align="center"><img src="/img/图像处理算法/基础/13.png" alt="高斯核"></div></p>
<h4 id="图像卷积"><a href="#图像卷积" class="headerlink" title="图像卷积"></a>图像卷积</h4><p>用一个模板和一副图像进行卷积，对于图上的一点，让模板的中点(几何中心点)和该点重合，然后模板上的点和图像对应点相乘，然后将各个点所得的乘积相加，就得到该点的卷积值．简单的来说就中心像素值和相邻像素的加权求和.</p>
<p><div align="center"><img src="/img/图像处理算法/基础/1.gif" alt="高斯核"></div></p>
<p>公式:</p>
<p><div align="center"><img src="/img/图像处理算法/基础/14.png" alt="高斯核"></div></p>
<p>算法实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 功能: 对图像进行卷积操作</span><br><span class="line">* 参数:</span><br><span class="line">*      input_image - 输入图像</span><br><span class="line">*</span><br><span class="line">**/</span><br><span class="line">void convolution(cv::Mat &amp;input_image, cv::Mat &amp;output_image, double **kernel, int size)</span><br><span class="line">&#123;</span><br><span class="line">  //找出卷积核的中心点</span><br><span class="line">  int center = size / 2;</span><br><span class="line">  cv::Mat temp_image = input_image.clone();</span><br><span class="line">  output_image = cv::Mat(temp_image.size(), temp_image.type());</span><br><span class="line">  for(int rows = 0; rows &lt; temp_image.rows; rows++)&#123;</span><br><span class="line">    for(int cols = 0; cols &lt; temp_image.cols; cols++)&#123;</span><br><span class="line">        double dst_pixel_value = 0.0;</span><br><span class="line">      for(int i = -size/2; i &lt;= size/2; i++)&#123;</span><br><span class="line">        for(int j = -size/2; j &lt;= size/2; j++)&#123;</span><br><span class="line">           int row = rows + i;</span><br><span class="line">           int col = cols + j;</span><br><span class="line">           //限幅，防止超出图片范围</span><br><span class="line">           row = row &gt;= temp_image.rows - 1 ? row - 1 : row;</span><br><span class="line">           row = row &lt; 0 ? 0:row;</span><br><span class="line">           col = col &gt;= temp_image.cols - 1? col - 1 : col;</span><br><span class="line">           col = col &lt; 0 ? 0 : col;</span><br><span class="line">           dst_pixel_value += temp_image.at&lt;uchar&gt;(row,col) * kernel[center+i][center+j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      output_image.at&lt;uchar&gt;(rows, cols) = static_cast&lt;uchar&gt;(dst_pixel_value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="setp2-计算梯度和方向"><a href="#setp2-计算梯度和方向" class="headerlink" title="setp2: 计算梯度和方向"></a>setp2: 计算梯度和方向</h3><p>图像的边缘处像素值变化比较剧烈，所以想要得到图像的边缘首先应该求出图像的梯度,图像的梯度就是对二元函数进行”导数”, Canny算子使用Sobel的四个算子来检测图像的水平丶垂直丶对角线边缘:</p>
<p><div align="center"><img src="/img/图像处理算法/基础/21.png" alt="双三次插值"></div></p>
<p><div align="center"><img src="/img/图像处理算法/基础/19.png" alt="双三次插值"></div></p>
<p><div align="center"><img src="/img/图像处理算法/基础/20.png" alt="双三次插值"></div></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="https://link.hhtjim.com/163/444951.mp3">
            </audio>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci="80462b0ab4b32ebdcfc4" data-cs="28aceed13b977f60d2728b5c85b3cf7160e272ca" data-r="RainBowAurora.github.io" data-o="RainBowAurora" data-a="RainBowAurora" data-d="false">查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Opencv的Mat数据转换"><span class="toc-number">1.</span> <span class="toc-text">Opencv的Mat数据转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mat-gt-Vector"><span class="toc-number">1.1.</span> <span class="toc-text">Mat -&gt; Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector-gt-Mat"><span class="toc-number">1.2.</span> <span class="toc-text">vector -&gt; Mat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组-gt-Mat"><span class="toc-number">1.3.</span> <span class="toc-text">数组-&gt;Mat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mat-gt-数组"><span class="toc-number">1.4.</span> <span class="toc-text">Mat-&gt;数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图像缩放"><span class="toc-number">2.</span> <span class="toc-text">图像缩放</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#最近邻插值"><span class="toc-number">2.1.</span> <span class="toc-text">最近邻插值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#距离度量"><span class="toc-number">2.1.1.</span> <span class="toc-text">距离度量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现"><span class="toc-number">2.1.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双线性插值"><span class="toc-number">2.2.</span> <span class="toc-text">双线性插值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双三次插值"><span class="toc-number">2.3.</span> <span class="toc-text">双三次插值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Canny边缘检测"><span class="toc-number">3.</span> <span class="toc-text">Canny边缘检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍"><span class="toc-number">3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Setp1-高斯平滑"><span class="toc-number">3.2.</span> <span class="toc-text">Setp1: 高斯平滑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#高斯核"><span class="toc-number">3.2.1.</span> <span class="toc-text">高斯核</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#图像卷积"><span class="toc-number">3.2.2.</span> <span class="toc-text">图像卷积</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setp2-计算梯度和方向"><span class="toc-number">3.3.</span> <span class="toc-text">setp2: 计算梯度和方向</span></a></li></ol></li></ol>
        </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>