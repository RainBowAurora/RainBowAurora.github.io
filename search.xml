<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[图像处理面试题]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"></content>
      <categories>
        <category>工作面试</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02 OpenCV-SVM]]></title>
    <url>%2F2019%2F02%2F27%2F02-OpenCV-SVM%2F</url>
    <content type="text"><![CDATA[分析需求 研发 测试 字体改成蓝色了 sdfsdfsf]]></content>
      <tags>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01 OpenCV-Mat]]></title>
    <url>%2F2019%2F02%2F19%2F01-OpenCV-Mat%2F</url>
    <content type="text"><![CDATA[起源OpenCV作为一个强大的开源计算机库,从早期的OpenCV1.x版本中,图像处理是通过lplimage(该名称源于另一个开源库Intel image Processing Library)结构来实现,早期的OpenCV完全是C的编程风格,lplimage结构是OpenCV矩阵运算的数据结构.到了OpenCV2.0版本,OpenCV开源库引入了面向对象的编程思想,大量的源代码用C++重新构建,Mat类(Matix矩阵的缩写),是OpenCV用于处理图像而引入的一个封装类,从功能上来讲,Mat类在lplimage结构基础上进一步增强,并且引入了C++高级特性,如果你要查看Mat定义的话可以到源代码目录下opencv/modules/core/include/opencv2/core/mat.hpp进行查看,你会发现其设计十分全面具体,基本覆盖了计算机视觉库对于图像处理的基本要求. 构造函数OpenCV包含有许多类型的构造函数,能够很方便用户的使用: 默认构造函数(无参构造函数) 1Mat::Mat() 使用行数 列书 图像类型 初始化的构造的函数 1Mat::Mat(int rows, int cols, int type) 使用size类型初始化图像大小的构造函数 1Mat::Mat(Size size, int type) 使用行数和列书设定图像大小,并且使用Scalar设置图像初始值 1Mat::Mat(int rows, int cols, int type, const Scalar &amp;s) 使用Size初始化图像大小,使用Scalar设置图像初始值 1Mat::Mat(Size size, int type, const Scalar &amp;s) 拷贝构造函数,属于浅拷贝 1Mat::Mat(const Mat &amp;m) 使用行数列数设置图像大小,不创建图像数据所需的内存,直接使用data所指内存,图像的步长由Setp决定 1Mat::Mat(int rows, int cols, int type, void *data, size_t step=AUTO_STEP) 使用Size指定图像大小,不创建图像数据所需的内存,直接使用data所指的内存,图像的步长由setp决定 1Mat::Mat(Size size, int type, void *data, size_t step=AUTO_SETP) 图像ＲＯＩ 1Mat::Mat(const Mat &amp;m, const Rect &amp;roi) 图像ＲＯＩ 1Mat::Mat(const Mat &amp;m, const Range&amp; rowRange, const Range&amp; colRange) 常用的成员函数OpenCV中有非常多的成员函数，基本能够满足大多数用户的使用，下面我们就来介绍一些常用的函数，以及他们的用法，如果想了解更加细致的解释，建议参考Opencv官方网站 Mat::Create创建新的矩阵数据123void Mat::create(int rows, int cols, int type)void Mat::create(Size size, int type)void Mat::create(int ndims, const int* sizes, inttype) rows-新的行数cols-新的列数size-替代新矩阵的大小规格sizes-指定一个新的矩阵形状的整数数组rype-新矩阵的类型ndims-新数组的维数 Mat::resize重新分配图像大小12void Mat::resize(size_t sz)void Mat::resize(size_t sz, const Scalar &amp;s) sz-新的行数s-分配新添加的元素的值 Mat::adjustROI调整子矩阵大小及其在父矩阵中的位置1Mat &amp;Mat::adjustROI(int dtop, int dbottom, int dleft, int dright) dtop-顶部子矩阵向上的平移量dbottom-底部子矩阵边界向下的平移量dleft-左边子矩阵边界向左的平移量dright-右边子矩阵向右的平移量 Mat::total返回数组元素的总数1size_t Mat::total() const Mat::isContinuous判断矩阵是否连续1bool Mat::isContinuous() const Mat::elemSize返回矩阵元素的大小(以字节为单位)1size_t Mat::elemSize() const 该方法返回以字节为单位的矩阵元素通道大小，例如：如果矩阵的类型是CV_16SC，该方法返回3*sizeof(short)或者６． Mat::depth返回一个矩阵的深度1int Mat::depth() const 该方法返回矩阵元素深度（每个单独通道类型）： 符号 类型 取值范围 CV_8U 8位无符号整数 0…..255 CV_8S 8位符号整数 -128…..127 CV16_U 16位无符号整数 0….65535 CV16_S 16位符号整数 -32768….32767 CV32_S 32位符号整数 -21473648….21473647 CV32_F 32位浮点数 -FLT_MAX….FLT_MAX CV64_F 64浮点数 -DBL_MAX….DBL_MAX Mat::channels返回矩阵通道的数目1int Mat::channels() const Mat::setp1返回矩阵归一化迈出的一步1size_t const Mat::setp1() 该方法返回以矩阵setp除以Mat::elemSize1().他对快速访问矩阵元素很有用 Mat::size返回一个矩阵的大小1Size Mat::size() const 该方法返回一个矩阵的大小：Size(cols, rows)，若据很超过二维则返回(-1, -1) Mat::empty如果数组没有elemens，则返回true，常用于判断图片是否被读取1bool Mat::empty() Mat::ptr返回指定矩阵行的指针1234uchar *Mat::ptr(int i=0)uconst uchar* Mat::ptr(int i=0) consttemplate&lt;typename _Tp&gt; _Tp* Mat::ptr(int i=0)template&lt;typename _Tp&gt; const _Tp* Mat::ptr(int i=0) const i-一个基于０行的索引 Mat::at返回指定数组元素的引用12345678910template&lt;typename T&gt; T&amp; Mat::at(int i) consttemplate&lt;typename T&gt; const T&amp;Mat::at(int i) consttemplate&lt;typename T&gt; T&amp; Mat::at(int i, int j) consttemplate&lt;typename T&gt; const T&amp;Mat::at(int i, int j) consttemplate&lt;typename T&gt; T&amp; Mat::at(Pointpt)template&lt;typename T&gt; const T&amp;Mat::at(Point pt) consttemplate&lt;typename T&gt; T&amp;Mat::at(int i, int j, int k)template&lt;typename T&gt; const T&amp;Mat::at(int i, int j, int k) consttemplate&lt;typename T&gt; T&amp;Mat::at(constint* idx)template&lt;typename T&gt; constT&amp;Mat::at(const int* idx) const i-0维度索引j-1唯独索引k-2维度索引pt-Point(i,j)作为指定元素的位置idx-Mat::dims数组的索引 Mat::begin返回矩阵迭代器，并设置为第一矩阵元12template&lt;typename _Tp&gt;MatIterator_&lt;_Tp&gt; Mat::begin()template&lt;typename _Tp&gt;MatConstIterator_&lt;_Tp&gt; Mat::begin() const Mat::end返回矩阵迭代器，并将其设置为最后元素的矩阵单元．12template&lt;typename _Tp&gt;MatIterator_&lt;_Tp&gt; Mat::end()template&lt;typename _Tp&gt;MatConstIterator_&lt;_Tp&gt; Mat::end() const 拓展有时在进行面试的时候，面试官提出一些有关编程方面的问题，让我们不许使用Opencv的Mat类．通常会提出数据类型转换问题,下面我们就此开始. Mat与数组之间互相转换数组转Mat12unsigned char buff[height][width];cv::Mat img(height, width, CV_8UC1, (unsigned char*)buff); Mat转数组 将Mat中的内容传递给数组，如果Mat中的数据是连续的，那么我们传递到一维vector我们可以这样： 1234std::vector&lt;uchar&gt; array(mat.total());if(mat.isContinuous())&#123; array = mat.data;&#125; 同样的，传递到一维数组我们可以： 1234unsigned char *arry = new unsigned char[mat.total()];if(mat.isContinuous())&#123; array = mat.data;&#125; 对于二维度vector传值: 1234567uchar **array = new uchar*[mat.rows];for(int i = 0; i &lt; mat.rows; ++i)&#123; array[i] = new uchar[mat.cols];&#125;for(int i = 0; i &lt; mat.rows; ++i)&#123; array[i] = mat.ptr&lt;uchar&gt;(i);&#125; Mat与vector互相转换 Mat转vector 12345template&lt;typename _Tp&gt;vector&lt;_Tp&gt; convertMat2Vector(const Mat &amp;mat)&#123; return (vector&lt;_Tp&gt;)(mat.reshape(1, 1)); //通道数不变，按行转为一行&#125; vector转Mat 1234567template&lt;typename _Tp&gt;cv::Mat convertVector2Mat(vector&lt;_Tp&gt; v, int channels, int rows)&#123; cv::Mat mat = cv::Mat(v); cv::Mat dest = mat.reshape(channels, rows).clone(); //必须clone一份，否则出现错误 return dest;&#125;]]></content>
      <tags>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用方法]]></title>
    <url>%2F2019%2F02%2F14%2Fgit%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本操作初始化下载1$ sudo apt-get install git 设置12$ git config --global user.name &quot;your name&quot;$ git config --global user.email &quot;your email&quot; 创建仓库 git init: 在一个文件目录执行该命令，会把该目录快速设置成Git的代码仓库。 git clone: 从远程服务器clone工程，也会创建一个代码长裤。 提交修改 git status: 查看当前仓库状态，会提示那些文件进行了修改，增加或者删除，那些内容还没有进行提交。 git status -s：用来查看当前仓库状态信息的简写：M-被修改、A-被添加、D-被删除、R-重命名、??-未跟踪 git add: 添加文件到暂存区。 如果工作区有我们你不想提交的文件可以设置忽略项，设置忽略项我们通常都是在.gitignore文件中设置，比如我们在要忽略grabage目录下的所有文件，我们只需： 在工作目录下新建一个名为.gitignore的文件 将我们要忽略的目录写入到文件当中，123$ touch .gitignore$ cat .gitignore/grabage/* 如果被排除目录下还有我们想要提交的文件，有两种方法： 在.gitignore文件中添加排除项 在提交时候使用git add -f &lt;file path&gt; git commit -m &quot;注释&quot;： 将暂存区的的修改提交到版本库。 如果发现上一个注释写错，需要进行修改和追加，可以使用： 1git commit -amend -m &quot;追加注释，覆盖之前的注释&quot; git log:查看历史提交信息。 git shortlog: 按照姓名对开发者分组，查看提交 git reflog: 查看所有操作历史。 修改比较 git diff &lt;file&gt; : 显示指定文件的前后变化 git diff HEAD : 与上一次提交进行对比 gitk: 图形化log记录 Git操作区域Git一共有三个区域： 工作区 - 开发修改代码的区域 如果工作区发生修改，则需要使用git add命令将修改提交到暂存区。 暂存区 - 在工作目录下./.git/index的文件中，板寸了所有代码提交的记录。 Git管理的是修改内容而不是文件 版本库区 - 保存了各个版本代码的区域。 通过git add命令提交修改之后，Head依然指向之前提交的内容，通过git commit将暂存区的内容提交之后，Head会指向最新内容。 Git退回 git reset --hard &lt;版本号&gt;: 将记录退回到版本号所在位置。 git reset --hard HEAD~3 : 表示退回三个版本 git checkout -- &lt;file&gt;: 可以丢弃工作区的修改。 git reset HEAD &lt;file&gt;: 可以把暂存区的修改撤销,重新放回工作区。 文件操作 git rm &lt;file&gt;: 删除文件。 文件暂存 git stash: 将当前内容进行暂存。 git stash list: 查看当前暂存区的内容。 git stash apply/pop: 内容恢复，后者会删除记录，前者可以通过git stash drop删除暂存记录。 远程仓库 ssh-keygen -t rsa -C &quot;yourname@example.com&quot;: 创建一个ssh-key，自动在用户家目录下创建一个.ssh目录，其中包含两个文件。 id_rsa: 私有密钥，不能泄露出去。id_rsa.pub: 共有密钥，可以放心告诉别人。 git remote add origin git@github.com:michaelliao/learngit.git: 仓库关联 git push -u origin master: 将本地的master分支提交到远程的master分支，并关联起来。 git pull -rebase: 如果Apush之前，Bpush了修改，Apush的时候需要从远程获取最新修改，这个指令不会产生过多的merge历史。git撤销提交到远程仓库的commitgit如果想撤销已经提交到远程仓库的commit，可以首先在仓库中使用git reset -hard[commit_id]将本地版本库重置为需要撤销的版本，然后使用git push -f origin进行提交，这样可以强制远程仓库与本地仓库一致。 比方说我想回到asdlk34ic这个commit_id： 首先我需要在本地进行还原 git reset --hard asdlk34ic 然后强制push到远程仓库。 git push -f origin 这样的操作方式可以使撤销的commit不在log日志中，或者也可以使用git revert命令进行撤销： git reset 主要有-soft -mixed -hard三种方式 -soft这个就是除了git commit还原其他的都保留，比如所git status里面的内容和代码的修改。-mixed这个就是除了代码修改保留外其他的都还原， 包括git commit 和git status里面的内容。-hard这个就是将所有的都还原，包括代码，git add后的内容以及git commit里面的内容。 分支管理 git checkout -b &lt;branch name&gt;: 新建并切换分支 上面的命令等价于：git branch &lt;branch name&gt;: 创建新分支git checkout &lt;brach name&gt;: 切换分支如果此时有未提交的修改是无法切换分之的，这个时候就可以用git stash进行暂存。 git branch: 查看分支 git branch -r: 查看所有远程分支。git branch -a: 显示所有本地分支和远程分支。 git merge &lt;branch name&gt;: 合并分支 在其他分支进行修改、add、commit后，切换到master分支，合并第一个分支到master分支。 git branch -d &lt;branch name&gt;: 删除分支 git branch -D &lt;branch name&gt;: 强制删除分支 git remote origin: 查看远程分支 git remote -v origin: 查看远程分支详细信息 git push origin &lt;branch name&gt;: 将分支推送到远程仓库 git push origin -delete &lt;branch name&gt;: 删除远程分支。 tag标签管理Tag用于记录某个commit点或者分支的历史快照，Tag通常打在Master分支上，以保证代码的准确性。 git tag v1.0:创建Tag，惠济路在最后的提交上。 git tag v1.0 &lt;commit_id&gt;: 在指定的commit_id上打标签 git tag:查看所有标签 git tag -a v.10 -m &quot;doc&quot; -a指定tag名字， -m指定注释文字 git show &lt;tag_name&gt;: 显示tag详细信息。 git tag -d &lt;tag_name&gt;: 删除标签 先删除本地标签，再从新Push到远程仓库。 git push origin &lt;tag_name&gt;: 推送tag到远程仓库 git push origin -tags: 推送所有的本地标签到远程仓库]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2019%2F02%2F13%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[认识MakedownMakedown是一种标记语言，大多数人第一个会想到Html,他就是一种标记语言（HTML应该是一种超文本标记语言，所谓超文本标记语言就是指文本中可以包含图片音乐、链接等非文字的元素，又称富文本，但是本质依然是一种标记语言）。所谓标记语言就是用特定的标识符对一段文字进行标记，从而实现使用者对文字的排版，而在此之前，我们实现文字排版大部分都是使用其他工具（WPS、World、Pages）等实现，但是不免存在一些弊端： 需要安装一个重量级的工具，不管时World、Pages还是WPS,安装起来都非常占用空间。 有些正版工具非常昂贵，盗版工具体验差（支持正版）。 工具版本不同，文本排版时可能会有些差别，也就是用World写一个文本，再用WPS打开有时会出现一些诸如排版、字体大小、行间距等等不一致的情况。 针对以上问题，标记性语言可以解决，他所具有的有点有： 轻量级，甚至已经有多款在线的makedown编辑工具也非常好用。 完全免费。 兼容性好，GitHub、CSDN、简书等网站均支持Markdown语法，不存在版本显示的问题。 语法简介标题在你想要设置标题的文字前面添加#，一个#是一级标题，两个#是二级标题，以此类推： 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 字体加粗在要加粗的文字左右两边分别用两个*包起来。斜体在要倾斜的文字左右两边分别用一个*包起来。斜体加粗在要斜体和加粗的文字左右分别用三个*包起来删除线在要贾删除线的文字左右两边分别用两个~号包起来。示例：1234*这是斜体文字***这是加粗文字*****斜体加粗文字***~~这是删除线文字~~ 效果:这是斜体文字这是加粗文字这是斜体加粗文字这是删除线文字 引用在引用的文字前面加&gt;即可。引用也可以嵌套，例如加两个 &gt;&gt; 三个 &gt;&gt;&gt; n个…示例：123&gt;这是引用内容&gt;&gt;注意，前方高能！&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;高能~ 效果： 这是引用内容 注意，前方高能！ 高能~ 分割线三个或者三个以上的 - 或者 * 都可以示例：12-----*** 效果： 图片语法：123![图片alt](图片的地址 &apos;&apos;图片titel&apos;&apos;)图片alt就是显示在图片下面的文字，一般是对图片的内容进行解释图片的titel就是图片的标题，当鼠标移动到图片上时显示的内容，titel可要可不要 示例：1![我是图片alt](/img/rainbow.png &apos;我是titel&apos;) 效果： markdown在插入图片时，默认图片靠左，有些时候我们想要设置图片居中，或者靠右就可以使用下面程序：12&lt;div align=center&gt;![这里写图片描述](http:...)&lt;div align=right&gt;![这里写图片描述](http:..) 实例： 图片居中 1&lt;div align=center&gt;![图片居中](/img/rainbowico.png) 图片靠右 1&lt;div align=center&gt;![图片靠右](/img/rainbowico.png) 效果： 图片居中 图片靠右 图片大小，有两种设置方法,一种是直接设置图片大小，另一种是输入缩放图片缩放百分比：12&lt;img src=&quot;http:...&quot; width = &quot;100&quot; height = &quot;100&quot; div align=right /&gt;&lt;img src=&quot;http:...&quot; width = 30% height = 30% /&gt; 实例： 图片大小为50x50 1&lt;img src=&quot;/img/rainbowico.png&quot; width = &quot;100&quot; height = &quot;100&quot; div align=right /&gt; 图片扩大20% 1&lt;img src=&quot;/img/rainbowico.png&quot; width = 20% height = 20% /&gt; 效果: 图片大小为50x50 图片扩大20% 超链接语法：12[超链接名](超链接地址， &apos;超链接title&apos;)跟图片类似title可加可不加 示例：12[Github](https://github.com)[！404](https://google.com) 效果:Github！404 注意:Markdown本身语法不支持链接在新页面打开，如果想要在新页面打开链接的话可以使用html语言的a标签代替1&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt; 示例：1&lt;a href=&quot;https://github.com/RainBowAurora&quot; target=&quot;_blank&quot;&gt;我的github&lt;/a&gt; 效果:我的github 列表 无序列表语法:无序列表用-+\*任何一种都可以12345- 列表内容1+ 列表内容2* 列表内容3注意： - + * 跟内容之间都有一个空格 效果： 列表内容1 列表内容2 列表内容3 有序列表语法：文字前数字加点 1231. 列表内容12. 列表内容23. 列表内容3 效果： 列表内容1 列表内容2 列表内容3 列表嵌套上一级和下一级之间加三个空格即可 一级无序内容 二级无序内容 二级无序内容 二级无序内容 一级无序内容 二级有序内容 二级有序内容 二级有序内容 一级有序内容 二级无序内容 二级无序内容 二级无序内容 一级有序内容 二级有序内容 二级有序内容 二级有序内容 表格语法：12345678910表头|表头|表头----|:--:|----:内容|内容|内容内容|内容|内容第二行分割表头和内容`-` 一个就够了，有时为了对齐可以多加几个文字默认居左`:-:`文字居中`-:`居右 示例：12345姓名|性别|年龄----|:--:|--:六六|女|28壮壮|男|25花花|男|30 效果： 姓名 性别 年龄 六六 女 28 壮壮 男 25 花花 男 30 注意：在编写表格的时候，表头之前因该空一行，否则表格不会正常显示。 代码语法：单行代码：代码之间分别用一个反引号扩起来1`单行代码` 代码块：代码之间用三个反引号扩起来，并且反引号独占一行12345（```） 代码 ... 代码 ... 代码 ...（```） 注意：为了防止转译，上述的代码块中的三个反引号添加了小括号()，在正常使用的时候没有小括号，这里只是为了演示。 示例： 单行代码 1`#include &lt;iostream&gt;` 代码块 12345678(```)#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; printf(&quot;Hello world~!&quot;); return 0;&#125;(```) 效果： 单行代码#include &lt;iostream&gt; 代码块123456#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; printf(&quot;Hello world~!&quot;); return 0; &#125; 代办事项代办事项和清单，在Ｍarkdown中，你住需要在代办的事项文本或者清单文本前面加上-[]即可． 语法： 表示未完成 表示已经完成 试例：123- [x] 分析需求- [ ] 研发- [ ] 测试 效果: 分析需求 研发 测试 转义符在markdown文档一般无法直接中输出被用于传唤格式的符号本身，通常需要用到转义符，也就是\来协助:如果要显示*,则可使用如下方式:1/* 常用的转义符号有：123456789101112\ 反斜线` 反引号\* 星号\_ 下划线&#123;&#125; 花括号[] 方括号() 圆括号# 井号+ 加号- 减号（连字符）. 句点! 感叹号 参考网址参考：https://www.jianshu.com/p/b421cc723da5https://www.jianshu.com/p/191d1e21f7edhttps://www.jianshu.com/p/335db5716248https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Mkdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
