<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[PathPlanning]AStar.md]]></title>
    <url>%2F2019%2F09%2F23%2FPathPlanning-AStar-md%2F</url>
    <content type="text"><![CDATA[Ａ*寻路算法A*搜索算法，俗称Ａ星算法，作为启发式搜错算法中的一种，这是一种在图形平面上，有多个节点路径，求出最低通过成本的算法．长用于游戏中的NPC的移动计算，或线上游戏BOT的移动计算上．该算法想Dijkstar算法一样，可以找到最短路径,也像BFS一样，进行启发式搜索． 算法思路 计算路径时主要利用一个公式来筛选最优路径点:f(n) = g(n) + h(n) 其中: fn(n)是节点n的综合优先，我们根据这个值的大小(一般选取最小)来判断该点是否是最优(最短)路径上的点,最终的路径就是有一系列最小点所组成的． g(n)是节点n距离起点的代价. h(n)是节点n距离终点的预计代价,这也就是A*算法的启发函数. A*算法计算过程中，每次从优先队列中选取f(n)优先级最高(值最小)的节点作为下一个待遍历的点(有点贪心算法的思想).另外Ａ*算法使用两个集合来表示待遍历的点以及已经遍历过的点,通常称之为open_set和close_set. 完整的Ａ*算法描述如下： 123456789101112131415* 初始化open_set和close_set;* 将起点加入open_set中，并设置优先级为0(优先级最高)* 如果open_set不为空,则从open_set中选取优先级最高的节点n: * 如果节点n为终点,则： * 从终点开始逐步跟踪parent节点,一直到达起点; * 返回找到的结果路径,算法结束; * 如果节点n不是终点,则: * 将节点n从open_set中删除,并加入close_set中; * 遍历节点n所有的临近点： *如果临近点m在close_set中，则： * 跳过选取下一个临近点 * 如果临近节点m也不在open_set中，则: * 设置节点m的parent为节点n * 计算节点m的优先级 * 将节点m加入open_set中 启发函数启发函数会影响A*算法的行为. 在极端情况下,当启发函数f(n)始终为0,则将由g(n)决定节点的优先级，此时算法退化成Dijkstara算法. 如果h(n)始终小于等于节点n到终点的代价,则Ａ*算法保证一定能够到最短路径．但是当h(n)的值越小，算法遍历越多的节点,也就导致算法越慢. 如果h(n)完全等于n节点到终点的代价,则Ａ*算法将找到最佳路径，并且速度很快,可惜的是,并非所有场景下都能做到这一点,因为在没有到达终点之前，我们很难确确切算出距离终点还有多远. 如果h(n)的值比节点n到终点的代价还要大,则A*算法不能保证找到最短路径. 在另外一个极端情况下,如果h(n)相较于g(n)大很多,则此时只有h(n)产生效果,这也就变成了最佳优先搜索. 由于上面这些信息，我们可以知道通过调节启发函数我们可以控制算法的速度和精确度,因为在一些情况,我们可能未必需要最短路径,而是希望能够尽快找到一个路径即可，这也是Ａ*算法比较灵活的地方． 对于网格形式的图，有一下这些启发函数可以使用: 如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离(Manhattan distance) 如果图形中允许朝八个方向移动，则可以使用对角距离. 如果图形中允许朝着任何方向移动，则可以使用欧几里得距离(Euclidean distance) 距离度量 曼哈顿距离如果图形中只允许朝上下左右四个方向移动，则启发函数可以使用曼哈顿距离: 1234function heuristic(node) = dx = abs(node.x - goal.x) dy = abs(node.y - goal.y) return D * (dx + dy) 对角距离如果允许朝八个方向移动，使用对角距离,其中D2指的是两个斜着相邻节点之间的移动代价，如果所有节点都是正方形其值为2^1/2 * D: 1234function heuristic(node) = dx = abs(node.x - goal.x) dy = abs(node.y - goal.y) return D * (dx + dy) + (D2 - 2*d) * min(dx, dy) 欧几里德距离如果图形中允许朝任意方向移动，可以使用欧几里德距离: 1234function heuristic(node) = dx = abs(node.x - goal.x) dy = abs(node.y - goal.y) return D * sqrt(dx * dx + dy * dy) 流程代码分析 这里所使用的代码是由AtsushiSakai所编写的(尊重原创) 坐标点与地图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def main(): print(__file__ + &quot; start!!&quot;) # start and goal position sx = 10.0 # 起始点的x坐标[m] sy = 10.0 # 起始点的y坐标[m] gx = 50.0 # 终止点的x坐标[m] gy = 50.0 # 终止点的y坐标[m] grid_size = 2.0 # 离散点间隔大小[m] robot_radius = 1.0 # 机器人半径用于碰撞检测[m] # set obstable positions 设置地图 ox, oy = [], [] for i in range(-10, 60): ox.append(i) oy.append(-10.0) for i in range(-10, 60): ox.append(60.0) oy.append(i) for i in range(-10, 61): ox.append(i) oy.append(60.0) for i in range(-10, 61): ox.append(-10.0) oy.append(i) #设置障碍物 for i in range(-10, 40): ox.append(20.0) oy.append(i) for i in range(0, 40): ox.append(40.0) oy.append(60.0 - i) if show_animation: # pragma: no cover 显示迷宫 plt.plot(ox, oy, &quot;.k&quot;) plt.plot(sx, sy, &quot;og&quot;) plt.plot(gx, gy, &quot;xb&quot;) plt.grid(True) plt.axis(&quot;equal&quot;) #创建 a_star类 a_star = AStarPlanner(ox, oy, grid_size, robot_radius) #启用路径规划 rx, ry = a_star.planning(sx, sy, gx, gy) #显示使用Ａ*规划出来的路径 if show_animation: # pragma: no cover plt.plot(rx, ry, &quot;-r&quot;) 这段代码说明如下: 首先人为初始化起点[10, 10]和终点[50, 50] 设置地图大小x(-10…60) y(-10…60)的正方形 设置地图中的障碍物 创建astar类调用规划算法算法主体算法主体是一个类封装的一系列函数:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205class AStarPlanner: def __init__(self, ox, oy, reso, rr): &quot;&quot;&quot; Initialize grid map for a star planning ox: x position list of Obstacles [m] oy: y position list of Obstacles [m] reso: grid resolution [m] rr: robot radius[m] &quot;&quot;&quot; self.reso = reso self.rr = rr self.calc_obstacle_map(ox, oy) self.motion = self.get_motion_model() class Node: def __init__(self, x, y, cost, pind): self.x = x # index of grid self.y = y # index of grid self.cost = cost self.pind = pind def __str__(self): return str(self.x) + &quot;,&quot; + str(self.y) + &quot;,&quot; + str(self.cost) + &quot;,&quot; + str(self.pind) def planning(self, sx, sy, gx, gy): &quot;&quot;&quot; A star path search input: sx: start x position [m] sy: start y position [m] gx: goal x position [m] gx: goal x position [m] output: rx: x position list of the final path ry: y position list of the final path &quot;&quot;&quot; #将起点节点初始化 nstart = self.Node(self.calc_xyindex(sx, self.minx), self.calc_xyindex(sy, self.miny), 0.0, -1) #终点节点初始化 ngoal = self.Node(self.calc_xyindex(gx, self.minx), self.calc_xyindex(gy, self.miny), 0.0, -1) open_set, closed_set = dict(), dict() open_set[self.calc_grid_index(nstart)] = nstart while 1: if len(open_set) == 0: print(&quot;Open set is empty..&quot;) break #使用lambda函数找出最小的f(n)对应的索引 c_id = min( open_set, key=lambda o: open_set[o].cost + self.calc_heuristic(ngoal, open_set[o])) current = open_set[c_id] # show graph if show_animation: # pragma: no cover plt.plot(self.calc_grid_position(current.x, self.minx), self.calc_grid_position(current.y, self.miny), &quot;xc&quot;) if len(closed_set.keys()) % 10 == 0: plt.pause(0.001) #等待0.001s #如果找到最终点则停止搜索 if current.x == ngoal.x and current.y == ngoal.y: print(&quot;Find goal&quot;) ngoal.pind = current.pind ngoal.cost = current.cost break # Remove the item from the open set del open_set[c_id] # Add it to the closed set closed_set[c_id] = current # expand_grid search grid based on motion model计算f(n) for i, _ in enumerate(self.motion): node = self.Node(current.x + self.motion[i][0], current.y + self.motion[i][1], current.cost + self.motion[i][2], c_id) #计算索引 n_id = self.calc_grid_index(node) # If the node is not safe, do nothing 判断节点是否安全 if not self.verify_node(node): continue # 如果节点被筛选过则跳过 if n_id in closed_set: continue #如果节点不再open_set中则将节点放入open_set中 if n_id not in open_set: open_set[n_id] = node # discovered a new node else: #如果节点在open_set中，则判断该节点是否是最优点(代价最小) if open_set[n_id].cost &gt; node.cost: # This path is the best until now. record it open_set[n_id] = node rx, ry = self.calc_final_path(ngoal, closed_set) return rx, ry def calc_final_path(self, ngoal, closedset): # generate final course 从终点反推到起点得出路径 rx, ry = [self.calc_grid_position(ngoal.x, self.minx)], [ self.calc_grid_position(ngoal.y, self.miny)] pind = ngoal.pind while pind != -1: n = closedset[pind] rx.append(self.calc_grid_position(n.x, self.minx)) ry.append(self.calc_grid_position(n.y, self.miny)) pind = n.pind return rx, ry @staticmethod def calc_heuristic(n1, n2): w = 1.0 # weight of heuristic ＃代价函数欧式距离 d = w * math.sqrt((n1.x - n2.x) ** 2 + (n1.y - n2.y) ** 2) return d # 索引-&gt;点 def calc_grid_position(self, index, minp): &quot;&quot;&quot; calc grid position :param index: :param minp: :return: &quot;&quot;&quot; pos = index * self.reso + minp return pos # 点 -&gt; 索引 def calc_xyindex(self, position, min_pos): return round((position - min_pos) / self.reso) def calc_grid_index(self, node): return (node.y - self.miny) * self.xwidth + (node.x - self.minx) def verify_node(self, node): px = self.calc_grid_position(node.x, self.minx) py = self.calc_grid_position(node.y, self.miny) #判断是否超出界限 if px &lt; self.minx: return False elif py &lt; self.miny: return False elif px &gt;= self.maxx: return False elif py &gt;= self.maxy: return False # collision check 判断是否是障碍 if self.obmap[node.x][node.y]: return False return True def calc_obstacle_map(self, ox, oy): #计算地图边界 self.minx = round(min(ox)) self.miny = round(min(oy)) self.maxx = round(max(ox)) self.maxy = round(max(oy)) print(&quot;minx:&quot;, self.minx) print(&quot;miny:&quot;, self.miny) print(&quot;maxx:&quot;, self.maxx) print(&quot;maxy:&quot;, self.maxy) # 计算地图宽度 self.xwidth = round((self.maxx - self.minx) / self.reso) self.ywidth = round((self.maxy - self.miny) / self.reso) print(&quot;xwidth:&quot;, self.xwidth) print(&quot;ywidth:&quot;, self.ywidth) # obstacle map generation self.obmap = [[False for i in range(self.ywidth)] for i in range(self.xwidth)] for ix in range(self.xwidth): x = self.calc_grid_position(ix, self.minx) for iy in range(self.ywidth): y = self.calc_grid_position(iy, self.miny) for iox, ioy in zip(ox, oy): d = math.sqrt((iox - x) ** 2 + (ioy - y) ** 2) if d &lt;= self.rr: self.obmap[ix][iy] = True break &quot;&quot;&quot; (-1,-1)[2*2/1] (0,-1)[1] (1, -1)[2*2/1] (-1, 0)[１] (0,0)[0] (1,0)[1] (-1, 1)[2*2/1] (0,1)[1] (1,1)[2*2/1] &quot;&quot;&quot; @staticmethod def get_motion_model(): # dx, dy, cost motion = [[1, 0, 1], [0, 1, 1], [-1, 0, 1], [0, -1, 1], [-1, -1, math.sqrt(2)], [-1, 1, math.sqrt(2)], [1, -1, math.sqrt(2)], [1, 1, math.sqrt(2)]] return motion 这段代码说明如下: __init__: 类构造函数,他需要ox(起始点x坐标), oy(起始点y坐标), reso(离散点的间隔大小), rr(机器人半径)等参数 __str__: 打印类中的具体属性 planning: 规划函数,可以规划出一条从起点到终点的最短路径，其接受四个参数sx(起始点x坐标), sy(起始点y坐标), gx(终点x坐标), gy(终点y坐标) 返回从起点到终点的路径点 calc_final_path: 生成最终轨迹, ngoal(终点索引和代价), colse_set(检索过点的集合) calc_heuristic: 启发函数采用欧几里德距离,输入两个点计算完成之后返回距离 calc_grid_position: 计算网格位置 calc_xyindex: 计算点x,y坐标索引 calc_grid_index: 计算栅格索引 verify_node: 检验输入的节点是否合法 calc_obstacle_map: 障碍地图生成 get_motion_model: 静态方法，用于制定g(n)的规则]]></content>
      <tags>
        <tag>Planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理基础算法]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Opencv的Mat数据转换 Mat -&gt; Vector vector -&gt; Mat uchar[] -&gt; Mat Mat -&gt; uchar[] Mat -&gt; Vector要将mat转换为vector可以借助opencv官方API将图像转换为行存入vector中．1Mat cv::Mat::reshape(int cn, int rows = 0) cons 功能: 在不复制数据的情况下更改二维矩阵的形状和通道数目．参数: cn 新的通道数，如果参数为0，则通道数保持不变． rows 新的行数，如果参数为0，则通道数保持不变. 12345template&lt;typename _Tp&gt;vector&lt;_Tp&gt; Mat2vector(const Mat &amp;mat)&#123; return (vector&lt;_Tp&gt;)(mat.reshape(1, 1));&#125; vector -&gt; MatMat构造函数可以将vector转换为一维Mat，之后可以使用上述的Mat::reshape将一维度数组转换成二维图像数组．1cv::Mat::Mat(const std::vector&lt; _Tp &gt; &amp;vec,bool copyData = false) 功能: 根据vector向量生成Mat,生成的Mat有一列，行数和元素个数相同.参数: vec vector类型的向量 copyData (true)是否将vector中的数据复制，(false)或与vector共享数据. 12345678template&lt;typename _Tp&gt;cv::Mat vector2Mat(vector&lt;_Tp&gt; vec, int channels, int rows)&#123; cv::Mat mat = cv::Mat(v, ture); //必须拷贝一份，否则会出错(多行一列) cv::Mat dst = mat.reshape(channels, rows).clone; return dst;&#125; 数组-&gt;Mat可以使用Mat的构造函数将数组转换为Mat类型.12cv::Mat::Mat(Size size, int type, void * data, size_t step = AUTO_STEP)cv::Mat::Mat(int rows, int cols, int type, void* data, size_t setp =AUTO_STEP) 功能: 将数组转化为Mat形参: rows 图像的行数 cols 图像的列数 size 图像的尺寸 type 图像的类新 CV_8UC\CV_32FC1 *data 图像数据 step 每个矩阵行所占的字节数 12345cv::Mat array2Mat(void* array, int rows, int cols, int type)&#123; cv::Mat dst(rows, cols, type, (void*)array) return dst.clone();&#125; Mat-&gt;数组对于连续的数组可以使用Mat::data()函数取出图像数据．123456789template&lt;class _Tp&gt;_Tp* Mat2array(const Mat &amp;mat)&#123; _Tp *array = new _Tp[mat.total()]; if(mat.isContinuous())&#123; array = mat.data; &#125; return array;&#125; 图像缩放&emsp;&emsp;图像缩放算法往往基于插值实现，常见的图像插值方法包括最近邻插值(Nearest-neighbor)丶双线性插值(Bilinear)丶双立方插值(bicubic)丶方向插值(Edge-directed interpolation)丶基于深度学习等算法．公式推导 最近邻插值最近邻插值是采取采样点周围四个相邻像素中距离最近的一个点的灰度值作为该点的灰度值的方法.Ｉ 优点:&emsp;&emsp;简单快速，灰度保真较好．缺点:&emsp;&emsp;会产生明显的锯齿和马赛克，视觉特性较差．公式: 引入0.5是为了让原图像与目标图像几何中心对齐． 距离度量如下图所示，P为目标图像中对应到原始图像中的点(亚像素)，Q11丶Q12丶Q21丶Q22是P点周围的四个整数点,可以根据距离度量公式(De欧氏距离丶D4城市街区距离丶D8棋盘距离)欧氏距离De: － 城市距离D4: － － － 欧几里德距离欧几里德距离简称欧氏距离，也就是我们通常所说的亮点之间的直线距离. 12345double distance_euclid(double x0, double y0, double x1, double y1)&#123; double distance = sqrt(pow((x0 - x1), 2)+ pow((y0 - y1), 2)); return distance;&#125; 城市距离(曼哈顿距离)出租车几何或曼哈顿距离，用以表明两个点在基准坐标系下绝对轴距之和. 12345double distance_manhattan(double x0, double y0, double x1, double y1)&#123; double distance = fabs(x0 - x1)+fabs(y0 - y1); return distance;&#125; 棋盘距离(切比雪夫距离)在国际棋盘上，王从一点到另一点的距离 12345void distance_checkerboard(double x0, double y0, double x1, double y1)&#123; double distance = fabs(x0 - x1) &gt; fabs(y0 - y1)?fabs(x0 - x1):fabs(y0 - y1); return distance;&#125; 代码实现为了简单直观，这里直接使用但通道图像做演示．1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/*** 函数功能:使用最近邻插值方法缩放图像* 参数:* input_image - 输入图像(单色图像)* output_image - 输出图像* size -输出图像大小(像素)* distance_type - 计算距离方法 0 欧式距离 1 曼哈顿距离 2 切比雪夫距离**/void nearestScaler(cv::Mat &amp;input_image, cv::Mat &amp;output_image, cv::Size size, int distance_type)&#123; //拷贝输入图像 cv::Mat temp_image = input_image.clone(); output_image = cv::Mat(size, temp_image.type()); //计算缩放比例 double scale_row = static_cast&lt;double&gt;(temp_image.rows)/size.height; double scale_col = static_cast&lt;double&gt;(temp_image.cols)/size.width; //遍历图像 for(int rows = 0; rows &lt; size.height; rows++)&#123; for(int cols = 0; cols &lt; size.width; cols++)&#123; //计算缩放后原始图坐标 double x = (rows + 0.5) * scale_row + 0.5; double y = (cols + 0.5) * scale_col + 0.5; //找出坐标周围的四个点 int x0 = static_cast&lt;uint&gt;(x); if(x0 &gt; temp_image.rows - 1) x0 = temp_image.rows - 1; int x1 = x0 + 1; int y0 = static_cast&lt;uint&gt;(y); if(y0 &gt; temp_image.cols - 1) y0 = temp_image.cols - 1; int y1 = y0 + 1; //使用距离度量公式找出最小距离 std::vector&lt;double&gt;dist(4); switch(distance_type)&#123; case 0://欧氏距离 dist[0] = distance_euclid(x, y, x0, y0); dist[1] = distance_euclid(x, y, x1, y0); dist[2] = distance_euclid(x, y, x0, y1); dist[3] = distance_euclid(x, y, x1, y1); break; case 1://曼哈顿距离 dist[0] = distance_manhattan(x, y, x0 ,y0); dist[1] = distance_manhattan(x, y, x1 ,y0); dist[2] = distance_manhattan(x, y, x0 ,y1); dist[3] = distance_manhattan(x, y, x1 ,y1); break; case 2://棋盘距离 dist[0] = distance_checkerboard(x, y, x0, y0); dist[1] = distance_checkerboard(x, y, x1, y0); dist[2] = distance_checkerboard(x, y, x0, y1); dist[3] = distance_checkerboard(x, y, x1, y1); break; default: break; &#125; //找出最小距离对因的下标 auto smallest = min_element(std::begin(dist), std::end(dist)); int min_index = distance(std::begin(dist), smallest); //图像插值 switch(min_index)&#123; case 0: output_image.at&lt;uchar&gt;(rows, cols) = temp_image.at&lt;uchar&gt;(x0, y0); break; case 1: output_image.at&lt;uchar&gt;(rows, cols) = temp_image.at&lt;uchar&gt;(x1, y0); break; case 2: output_image.at&lt;uchar&gt;(rows, cols) = temp_image.at&lt;uchar&gt;(x0, y1); break; case 3: output_image.at&lt;uchar&gt;(rows, cols) = temp_image.at&lt;uchar&gt;(x1, y1); break; default: break; &#125; &#125; &#125;&#125; 额外参考:https://blog.csdn.net/ccblogger/article/details/72918354 双线性插值双线性插值利用周围四个点的灰度值在两个方向上做线性插值得到采样点的灰度值． 优点:&emsp;&emsp; 1. 计算中较为充分的考虑了相邻各个点的特征，具有灰度平滑过渡的特点．&emsp;&emsp; 2. 一般情况下可以得到满意的结果 缺点:&emsp;&emsp; 1. 具有地通滤波特性，使图像轮廓模糊&emsp;&emsp; 2. 平滑做用使得图像细节退化，尤其在放大的时候尤为明显． 公式: 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 函数功能: 双线性插值缩放图像 * 参数: * input_image - 输入图像 * output_image - 输出图像 * size - 缩放尺寸 * 备注: * 只能进行单通道图片缩放 **/void bilinearIntertpolatioin(cv::Mat &amp;input_image, cv::Mat &amp;output_image, cv::Size size)&#123; cv::Mat temp_image = input_image.clone(); output_image = cv::Mat(size, temp_image.type()); //计算缩放比例 double scalar_rows = static_cast&lt;double&gt;(temp_image.rows) / size.height; double scalar_cols = static_cast&lt;double&gt;(temp_image.cols) / size.width; for(int rows = 0; rows &lt; size.height; rows++)&#123; for(int cols = 0; cols &lt; size.width; cols++)&#123; double x = (rows + 0.5) * scalar_rows - 0.5; double y = (cols + 0.5) * scalar_cols - 0.5; //防止超出图像边界 double x0 = static_cast&lt;uint&gt;(x); x0 = x0 &lt; 0? 0:x0; x0 = x0 &gt; (temp_image.rows - 1)? (temp_image.rows - 1) : x0; double x1 = x0 + 1; double y0 = static_cast&lt;uint&gt;(y); y0 = y0 &lt; 0? 0 : y0; y0 = y0 &gt; (temp_image.cols -1)? (temp_image.cols - 1) : y0; double y1 = y0 + 1; cv::Matx12d matx = &#123;x1 - x, x - x0&#125;; cv::Matx22d matd = &#123;static_cast&lt;double&gt;(temp_image.at&lt;uchar&gt;(x0, y0)), static_cast&lt;double&gt;(temp_image.at&lt;uchar&gt;(x0, y1)), static_cast&lt;double&gt;(temp_image.at&lt;uchar&gt;(x1, y0)), static_cast&lt;double&gt;(temp_image.at&lt;uchar&gt;(x1,y1))&#125;; cv::Matx21d maty = &#123;y1 - y, y - y0&#125;; auto val = matx * matd * maty; output_image.at&lt;uchar&gt;(rows, cols) = val(0, 0); &#125; &#125;&#125; static_cast()只保留整数部分，小数部分被舍弃:static_cast&lt;uchar&gt;(4.1)结果为4static_cast&lt;uchar&gt;(4.8)结果也为4 双三次插值双三次插值方法，(三次立方插值法或CC插值法)，是一种利用待插值点16个邻点像素值经过计算得到，没一个点需要经过５次计算，所以耗费时间长． 优点:&emsp;&emsp; 1. 三次卷积内插法减少高频损失，可以有效的平滑噪声．&emsp;&emsp; 2. 三次卷积内差法可以得到最佳结果(相比于上面两种插值方法)． 缺点:&emsp;&emsp; 计算量大，所需时间长． 公式: Canny边缘检测介绍Canny算子是John Canny在1986年提出的一种边缘检测方法．Canny的目地就是找到一个最优的边缘检测算法，优的边缘检测含义是: 最优检测:算法能够尽可能地多标识出图像中的实际边缘. - 边缘全 检测到的便晕应精确的定位在真实边缘的中心． - 定位准确 途中给定的边缘只标记一次, 并且在可能的情况下，图像的噪声不产生假的边缘． - 抗噪声能力强步骤:&emsp;&emsp;高斯平滑滤波-&gt;计算梯度和方向-&gt;非极大值抑制-&gt;双阈值检测和连接边缘 Setp1: 高斯平滑高斯核&emsp;&emsp;高斯模糊(Gaussian Blur)，也叫做高斯平滑，通常用它来减少噪声以及降低细节测层次.高斯模糊对于原图想来说是一个低通滤波器.公式: σ:标准差，其越大图像越模糊 代码实现:12345678910111213141516171819202122232425/*** 功能: 求解高斯核* 参数:* sigma - σ(标准差)* size - 高斯矩阵大小(只能是奇数)**///高斯卷积核生成void getOneGuassionArray(int size, double sigma, double **gauss)&#123; double pi = 3.1415927; int center = size/2; double sum = 0.0; for(int i = 0; i &lt; size; i++)&#123; for(int j = 0; j &lt; size; j++)&#123; gauss[i][j] = exp(-(pow((i-center),2) + pow((j-center),2))/(2*pow(sigma,2))) / (2*pi*pow(sigma,2)); sum += gauss[i][j]; &#125; &#125; for(int i = 0; i &lt; size; i++)&#123; for(int j = 0; j &lt; size; j++)&#123; gauss[i][j] = gauss[i][j] / sum; &#125; &#125;&#125; 结果:下面是σ = 0.5,size = 3所得到的高斯核 图像卷积用一个模板和一副图像进行卷积，对于图上的一点，让模板的中点(几何中心点)和该点重合，然后模板上的点和图像对应点相乘，然后将各个点所得的乘积相加，就得到该点的卷积值．简单的来说就中心像素值和相邻像素的加权求和. 公式: 算法实现:12345678910111213141516171819202122232425262728293031/*** 功能: 对图像进行卷积操作* 参数:* input_image - 输入图像***/void convolution(cv::Mat &amp;input_image, cv::Mat &amp;output_image, double **kernel, int size)&#123; //找出卷积核的中心点 int center = size / 2; cv::Mat temp_image = input_image.clone(); output_image = cv::Mat(temp_image.size(), temp_image.type()); for(int rows = 0; rows &lt; temp_image.rows; rows++)&#123; for(int cols = 0; cols &lt; temp_image.cols; cols++)&#123; double dst_pixel_value = 0.0; for(int i = -size/2; i &lt;= size/2; i++)&#123; for(int j = -size/2; j &lt;= size/2; j++)&#123; int row = rows + i; int col = cols + j; //限幅，防止超出图片范围 row = row &gt;= temp_image.rows - 1 ? row - 1 : row; row = row &lt; 0 ? 0:row; col = col &gt;= temp_image.cols - 1? col - 1 : col; col = col &lt; 0 ? 0 : col; dst_pixel_value += temp_image.at&lt;uchar&gt;(row,col) * kernel[center+i][center+j]; &#125; &#125; output_image.at&lt;uchar&gt;(rows, cols) = static_cast&lt;uchar&gt;(dst_pixel_value); &#125; &#125;&#125; setp2: 计算梯度和方向图像的边缘处像素值变化比较剧烈，所以想要得到图像的边缘首先应该求出图像的梯度,图像的梯度就是对二元函数进行”导数”, Canny算子使用Sobel的四个算子来检测图像的水平丶垂直丶对角线边缘:]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02 OpenCV-SVM]]></title>
    <url>%2F2019%2F02%2F27%2F02-OpenCV-SVM%2F</url>
    <content type="text"><![CDATA[SVM(Support Vector Machine)支撑向量机，使用支撑向量机既可以解决分类问题，还可以解决回归问题，SVM尝试寻找一个最优的决策边界距离两个类别的最近的样本最远，支撑向量机分为两种： Hard Margin SVM - 解决线性可分问题 Soft Margin SVM - 解决先行不可分问题 推理]]></content>
      <tags>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01 OpenCV-Mat]]></title>
    <url>%2F2019%2F02%2F19%2F01-OpenCV-Mat%2F</url>
    <content type="text"><![CDATA[起源OpenCV作为一个强大的开源计算机库,从早期的OpenCV1.x版本中,图像处理是通过lplimage(该名称源于另一个开源库Intel image Processing Library)结构来实现,早期的OpenCV完全是C的编程风格,lplimage结构是OpenCV矩阵运算的数据结构.到了OpenCV2.0版本,OpenCV开源库引入了面向对象的编程思想,大量的源代码用C++重新构建,Mat类(Matix矩阵的缩写),是OpenCV用于处理图像而引入的一个封装类,从功能上来讲,Mat类在lplimage结构基础上进一步增强,并且引入了C++高级特性,如果你要查看Mat定义的话可以到源代码目录下opencv/modules/core/include/opencv2/core/mat.hpp进行查看,你会发现其设计十分全面具体,基本覆盖了计算机视觉库对于图像处理的基本要求. 构造函数OpenCV包含有许多类型的构造函数,能够很方便用户的使用: 默认构造函数(无参构造函数) 1Mat::Mat() 使用行数 列书 图像类型 初始化的构造的函数 1Mat::Mat(int rows, int cols, int type) 使用size类型初始化图像大小的构造函数 1Mat::Mat(Size size, int type) 使用行数和列书设定图像大小,并且使用Scalar设置图像初始值 1Mat::Mat(int rows, int cols, int type, const Scalar &amp;s) 使用Size初始化图像大小,使用Scalar设置图像初始值 1Mat::Mat(Size size, int type, const Scalar &amp;s) 拷贝构造函数,属于浅拷贝 1Mat::Mat(const Mat &amp;m) 使用行数列数设置图像大小,不创建图像数据所需的内存,直接使用data所指内存,图像的步长由Setp决定 1Mat::Mat(int rows, int cols, int type, void *data, size_t step=AUTO_STEP) 使用Size指定图像大小,不创建图像数据所需的内存,直接使用data所指的内存,图像的步长由setp决定 1Mat::Mat(Size size, int type, void *data, size_t step=AUTO_SETP) 图像ＲＯＩ 1Mat::Mat(const Mat &amp;m, const Rect &amp;roi) 图像ＲＯＩ 1Mat::Mat(const Mat &amp;m, const Range&amp; rowRange, const Range&amp; colRange) 常用的成员函数OpenCV中有非常多的成员函数，基本能够满足大多数用户的使用，下面我们就来介绍一些常用的函数，以及他们的用法，如果想了解更加细致的解释，建议参考Opencv官方网站 Mat::Create创建新的矩阵数据123void Mat::create(int rows, int cols, int type)void Mat::create(Size size, int type)void Mat::create(int ndims, const int* sizes, inttype) rows-新的行数cols-新的列数size-替代新矩阵的大小规格sizes-指定一个新的矩阵形状的整数数组rype-新矩阵的类型ndims-新数组的维数 Mat::resize重新分配图像大小12void Mat::resize(size_t sz)void Mat::resize(size_t sz, const Scalar &amp;s) sz-新的行数s-分配新添加的元素的值 Mat::adjustROI调整子矩阵大小及其在父矩阵中的位置1Mat &amp;Mat::adjustROI(int dtop, int dbottom, int dleft, int dright) dtop-顶部子矩阵向上的平移量dbottom-底部子矩阵边界向下的平移量dleft-左边子矩阵边界向左的平移量dright-右边子矩阵向右的平移量 Mat::total返回数组元素的总数1size_t Mat::total() const Mat::isContinuous判断矩阵是否连续1bool Mat::isContinuous() const Mat::elemSize返回矩阵元素的大小(以字节为单位)1size_t Mat::elemSize() const 该方法返回以字节为单位的矩阵元素通道大小，例如：如果矩阵的类型是CV_16SC，该方法返回3*sizeof(short)或者６． Mat::depth返回一个矩阵的深度1int Mat::depth() const 该方法返回矩阵元素深度（每个单独通道类型）： 符号 类型 取值范围 CV_8U 8位无符号整数 0…..255 CV_8S 8位符号整数 -128…..127 CV16_U 16位无符号整数 0….65535 CV16_S 16位符号整数 -32768….32767 CV32_S 32位符号整数 -21473648….21473647 CV32_F 32位浮点数 -FLT_MAX….FLT_MAX CV64_F 64浮点数 -DBL_MAX….DBL_MAX Mat::channels返回矩阵通道的数目1int Mat::channels() const Mat::setp1返回矩阵归一化迈出的一步1size_t const Mat::setp1() 该方法返回以矩阵setp除以Mat::elemSize1().他对快速访问矩阵元素很有用 Mat::size返回一个矩阵的大小1Size Mat::size() const 该方法返回一个矩阵的大小：Size(cols, rows)，若据很超过二维则返回(-1, -1) Mat::empty如果数组没有elemens，则返回true，常用于判断图片是否被读取1bool Mat::empty() Mat::ptr返回指定矩阵行的指针1234uchar *Mat::ptr(int i=0)uconst uchar* Mat::ptr(int i=0) consttemplate&lt;typename _Tp&gt; _Tp* Mat::ptr(int i=0)template&lt;typename _Tp&gt; const _Tp* Mat::ptr(int i=0) const i-一个基于０行的索引 Mat::at返回指定数组元素的引用12345678910template&lt;typename T&gt; T&amp; Mat::at(int i) consttemplate&lt;typename T&gt; const T&amp;Mat::at(int i) consttemplate&lt;typename T&gt; T&amp; Mat::at(int i, int j) consttemplate&lt;typename T&gt; const T&amp;Mat::at(int i, int j) consttemplate&lt;typename T&gt; T&amp; Mat::at(Pointpt)template&lt;typename T&gt; const T&amp;Mat::at(Point pt) consttemplate&lt;typename T&gt; T&amp;Mat::at(int i, int j, int k)template&lt;typename T&gt; const T&amp;Mat::at(int i, int j, int k) consttemplate&lt;typename T&gt; T&amp;Mat::at(constint* idx)template&lt;typename T&gt; constT&amp;Mat::at(const int* idx) const i-0维度索引j-1唯独索引k-2维度索引pt-Point(i,j)作为指定元素的位置idx-Mat::dims数组的索引 Mat::begin返回矩阵迭代器，并设置为第一矩阵元12template&lt;typename _Tp&gt;MatIterator_&lt;_Tp&gt; Mat::begin()template&lt;typename _Tp&gt;MatConstIterator_&lt;_Tp&gt; Mat::begin() const Mat::end返回矩阵迭代器，并将其设置为最后元素的矩阵单元．12template&lt;typename _Tp&gt;MatIterator_&lt;_Tp&gt; Mat::end()template&lt;typename _Tp&gt;MatConstIterator_&lt;_Tp&gt; Mat::end() const 拓展有时在进行面试的时候，面试官提出一些有关编程方面的问题，让我们不许使用Opencv的Mat类．通常会提出数据类型转换问题,下面我们就此开始. Mat与数组之间互相转换数组转Mat12unsigned char buff[height][width];cv::Mat img(height, width, CV_8UC1, (unsigned char*)buff); Mat转数组 将Mat中的内容传递给数组，如果Mat中的数据是连续的，那么我们传递到一维vector我们可以这样： 1234std::vector&lt;uchar&gt; array(mat.total());if(mat.isContinuous())&#123; array = mat.data;&#125; 同样的，传递到一维数组我们可以： 1234unsigned char *arry = new unsigned char[mat.total()];if(mat.isContinuous())&#123; array = mat.data;&#125; 对于二维度vector传值: 1234567uchar **array = new uchar*[mat.rows];for(int i = 0; i &lt; mat.rows; ++i)&#123; array[i] = new uchar[mat.cols];&#125;for(int i = 0; i &lt; mat.rows; ++i)&#123; array[i] = mat.ptr&lt;uchar&gt;(i);&#125; Mat与vector互相转换 Mat转vector 12345template&lt;typename _Tp&gt;vector&lt;_Tp&gt; convertMat2Vector(const Mat &amp;mat)&#123; return (vector&lt;_Tp&gt;)(mat.reshape(1, 1)); //通道数不变，按行转为一行&#125; vector转Mat 1234567template&lt;typename _Tp&gt;cv::Mat convertVector2Mat(vector&lt;_Tp&gt; v, int channels, int rows)&#123; cv::Mat mat = cv::Mat(v); cv::Mat dest = mat.reshape(channels, rows).clone(); //必须clone一份，否则出现错误 return dest;&#125;]]></content>
      <tags>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用方法]]></title>
    <url>%2F2019%2F02%2F14%2Fgit%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本操作初始化下载1$ sudo apt-get install git 设置12$ git config --global user.name &quot;your name&quot;$ git config --global user.email &quot;your email&quot; 创建仓库 git init: 在一个文件目录执行该命令，会把该目录快速设置成Git的代码仓库。 git clone: 从远程服务器clone工程，也会创建一个代码长裤。 提交修改 git status: 查看当前仓库状态，会提示那些文件进行了修改，增加或者删除，那些内容还没有进行提交。 git status -s：用来查看当前仓库状态信息的简写：M-被修改、A-被添加、D-被删除、R-重命名、??-未跟踪 git add: 添加文件到暂存区。 如果工作区有我们你不想提交的文件可以设置忽略项，设置忽略项我们通常都是在.gitignore文件中设置，比如我们在要忽略grabage目录下的所有文件，我们只需： 在工作目录下新建一个名为.gitignore的文件 将我们要忽略的目录写入到文件当中，123$ touch .gitignore$ cat .gitignore/grabage/* 如果被排除目录下还有我们想要提交的文件，有两种方法： 在.gitignore文件中添加排除项 在提交时候使用git add -f &lt;file path&gt; git commit -m &quot;注释&quot;： 将暂存区的的修改提交到版本库。 如果发现上一个注释写错，需要进行修改和追加，可以使用： 1git commit -amend -m &quot;追加注释，覆盖之前的注释&quot; git log:查看历史提交信息。 git shortlog: 按照姓名对开发者分组，查看提交 git reflog: 查看所有操作历史。 修改比较 git diff &lt;file&gt; : 显示指定文件的前后变化 git diff HEAD : 与上一次提交进行对比 gitk: 图形化log记录 Git操作区域Git一共有三个区域： 工作区 - 开发修改代码的区域 如果工作区发生修改，则需要使用git add命令将修改提交到暂存区。 暂存区 - 在工作目录下./.git/index的文件中，板寸了所有代码提交的记录。 Git管理的是修改内容而不是文件 版本库区 - 保存了各个版本代码的区域。 通过git add命令提交修改之后，Head依然指向之前提交的内容，通过git commit将暂存区的内容提交之后，Head会指向最新内容。 Git退回 git reset --hard &lt;版本号&gt;: 将记录退回到版本号所在位置。 git reset --hard HEAD~3 : 表示退回三个版本 git checkout -- &lt;file&gt;: 可以丢弃工作区的修改。 git reset HEAD &lt;file&gt;: 可以把暂存区的修改撤销,重新放回工作区。 git commit -m --amend: 撤销上一次提交，并将暂存区文件重新提交 文件操作 git rm &lt;file&gt;: 删除文件。 文件暂存 git stash: 将当前内容进行暂存。 git stash list: 查看当前暂存区的内容。 git stash apply/pop: 内容恢复，后者会删除记录，前者可以通过git stash drop删除暂存记录。 远程仓库 ssh-keygen -t rsa -C &quot;yourname@example.com&quot;: 创建一个ssh-key，自动在用户家目录下创建一个.ssh目录，其中包含两个文件。 id_rsa: 私有密钥，不能泄露出去。id_rsa.pub: 共有密钥，可以放心告诉别人。 git remote add origin git@github.com:michaelliao/learngit.git: 仓库关联 git push -u origin master: 将本地的master分支提交到远程的master分支，并关联起来。 git pull -rebase: 如果Apush之前，Bpush了修改，Apush的时候需要从远程获取最新修改，这个指令不会产生过多的merge历史。git撤销提交到远程仓库的commitgit如果想撤销已经提交到远程仓库的commit，可以首先在仓库中使用git reset -hard[commit_id]将本地版本库重置为需要撤销的版本，然后使用git push -f origin进行提交，这样可以强制远程仓库与本地仓库一致。 比方说我想回到asdlk34ic这个commit_id： 首先我需要在本地进行还原 git reset --hard asdlk34ic 然后强制push到远程仓库。 git push -f origin 这样的操作方式可以使撤销的commit不在log日志中，或者也可以使用git revert命令进行撤销： git reset 主要有-soft -mixed -hard三种方式 -soft这个就是除了git commit还原其他的都保留，比如所git status里面的内容和代码的修改。-mixed这个就是除了代码修改保留外其他的都还原， 包括git commit 和git status里面的内容。-hard这个就是将所有的都还原，包括代码，git add后的内容以及git commit里面的内容。 分支管理 git checkout -b &lt;branch name&gt;: 新建并切换分支 上面的命令等价于：git branch &lt;branch name&gt;: 创建新分支git checkout &lt;brach name&gt;: 切换分支如果此时有未提交的修改是无法切换分之的，这个时候就可以用git stash进行暂存。 git branch: 查看分支 git branch -r: 查看所有远程分支。git branch -a: 显示所有本地分支和远程分支。 git merge &lt;branch name&gt;: 合并分支 在其他分支进行修改、add、commit后，切换到master分支，合并第一个分支到master分支。 git branch -d &lt;branch name&gt;: 删除分支 git branch -D &lt;branch name&gt;: 强制删除分支 git remote origin: 查看远程分支 git remote -v origin: 查看远程分支详细信息 git push origin &lt;branch name&gt;: 将分支推送到远程仓库 git push origin --delete &lt;branch name&gt;: 删除远程分支。 有时先删除本地的分支，然后在删除远程的分支，造成远程服务器内容和本地不相符，会报以下错误:error: unable to delete ‘origin/dev2’: remote ref does not exist`这时需要先从远程服务器拉去文件，然后在提出修改/删除:git pull origin tag标签管理Tag用于记录某个commit点或者分支的历史快照，Tag通常打在Master分支上，以保证代码的准确性。 git tag v1.0:创建Tag，惠济路在最后的提交上。 git tag v1.0 &lt;commit_id&gt;: 在指定的commit_id上打标签 git tag:查看所有标签 git tag -a v.10 -m &quot;doc&quot; -a指定tag名字， -m指定注释文字 git show &lt;tag_name&gt;: 显示tag详细信息。 git tag -d &lt;tag_name&gt;: 删除标签 先删除本地标签，再从新Push到远程仓库。 git push origin &lt;tag_name&gt;: 推送tag到远程仓库 git push origin -tags: 推送所有的本地标签到远程仓库]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2019%2F02%2F13%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[认识MakedownMakedown是一种标记语言，大多数人第一个会想到Html,他就是一种标记语言（HTML应该是一种超文本标记语言，所谓超文本标记语言就是指文本中可以包含图片音乐、链接等非文字的元素，又称富文本，但是本质依然是一种标记语言）。所谓标记语言就是用特定的标识符对一段文字进行标记，从而实现使用者对文字的排版，而在此之前，我们实现文字排版大部分都是使用其他工具（WPS、World、Pages）等实现，但是不免存在一些弊端： 需要安装一个重量级的工具，不管时World、Pages还是WPS,安装起来都非常占用空间。 有些正版工具非常昂贵，盗版工具体验差（支持正版）。 工具版本不同，文本排版时可能会有些差别，也就是用World写一个文本，再用WPS打开有时会出现一些诸如排版、字体大小、行间距等等不一致的情况。 针对以上问题，标记性语言可以解决，他所具有的有点有： 轻量级，甚至已经有多款在线的makedown编辑工具也非常好用。 完全免费。 兼容性好，GitHub、CSDN、简书等网站均支持Markdown语法，不存在版本显示的问题。 语法简介标题在你想要设置标题的文字前面添加#，一个#是一级标题，两个#是二级标题，以此类推： 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 字体加粗在要加粗的文字左右两边分别用两个*包起来。斜体在要倾斜的文字左右两边分别用一个*包起来。斜体加粗在要斜体和加粗的文字左右分别用三个*包起来删除线在要贾删除线的文字左右两边分别用两个~号包起来。示例：1234*这是斜体文字***这是加粗文字*****斜体加粗文字***~~这是删除线文字~~ 效果:这是斜体文字这是加粗文字这是斜体加粗文字这是删除线文字 引用在引用的文字前面加&gt;即可。引用也可以嵌套，例如加两个 &gt;&gt; 三个 &gt;&gt;&gt; n个…示例：123&gt;这是引用内容&gt;&gt;注意，前方高能！&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;高能~ 效果： 这是引用内容 注意，前方高能！ 高能~ 分割线三个或者三个以上的 - 或者 * 都可以示例：12-----*** 效果： 图片语法：123![图片alt](图片的地址 &apos;&apos;图片titel&apos;&apos;)图片alt就是显示在图片下面的文字，一般是对图片的内容进行解释图片的titel就是图片的标题，当鼠标移动到图片上时显示的内容，titel可要可不要 示例：1![我是图片alt](/img/rainbow.png &apos;我是titel&apos;) 效果： markdown在插入图片时，默认图片靠左，有些时候我们想要设置图片居中，或者靠右就可以使用下面程序：12&lt;div align=center&gt;![这里写图片描述](http:...)&lt;div align=right&gt;![这里写图片描述](http:..) 实例： 图片居中 1&lt;div align=center&gt;![图片居中](/img/rainbowico.png) 图片靠右 1&lt;div align=center&gt;![图片靠右](/img/rainbowico.png) 效果： 图片居中 图片靠右 图片大小，有两种设置方法,一种是直接设置图片大小，另一种是输入缩放图片缩放百分比：12&lt;img src=&quot;http:...&quot; width = &quot;100&quot; height = &quot;100&quot; div align=right /&gt;&lt;img src=&quot;http:...&quot; width = 30% height = 30% /&gt; 实例： 图片大小为50x50 1&lt;img src=&quot;/img/rainbowico.png&quot; width = &quot;100&quot; height = &quot;100&quot; div align=right /&gt; 图片扩大20% 1&lt;img src=&quot;/img/rainbowico.png&quot; width = 20% height = 20% /&gt; 效果: 图片大小为50x50 图片扩大20% 超链接语法：12[超链接名](超链接地址， &apos;超链接title&apos;)跟图片类似title可加可不加 示例：12[Github](https://github.com)[！404](https://google.com) 效果:Github！404 注意:Markdown本身语法不支持链接在新页面打开，如果想要在新页面打开链接的话可以使用html语言的a标签代替1&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt; 示例：1&lt;a href=&quot;https://github.com/RainBowAurora&quot; target=&quot;_blank&quot;&gt;我的github&lt;/a&gt; 效果:我的github 列表 无序列表语法:无序列表用-+\*任何一种都可以12345- 列表内容1+ 列表内容2* 列表内容3注意： - + * 跟内容之间都有一个空格 效果： 列表内容1 列表内容2 列表内容3 有序列表语法：文字前数字加点 1231. 列表内容12. 列表内容23. 列表内容3 效果： 列表内容1 列表内容2 列表内容3 列表嵌套上一级和下一级之间加三个空格即可 一级无序内容 二级无序内容 二级无序内容 二级无序内容 一级无序内容 二级有序内容 二级有序内容 二级有序内容 一级有序内容 二级无序内容 二级无序内容 二级无序内容 一级有序内容 二级有序内容 二级有序内容 二级有序内容 表格语法：12345678910表头|表头|表头----|:--:|----:内容|内容|内容内容|内容|内容第二行分割表头和内容`-` 一个就够了，有时为了对齐可以多加几个文字默认居左`:-:`文字居中`-:`居右 示例：12345姓名|性别|年龄----|:--:|--:六六|女|28壮壮|男|25花花|男|30 效果： 姓名 性别 年龄 六六 女 28 壮壮 男 25 花花 男 30 注意：在编写表格的时候，表头之前因该空一行，否则表格不会正常显示。 代码语法：单行代码：代码之间分别用一个反引号扩起来1`单行代码` 代码块：代码之间用三个反引号扩起来，并且反引号独占一行12345（```） 代码 ... 代码 ... 代码 ...（```） 注意：为了防止转译，上述的代码块中的三个反引号添加了小括号()，在正常使用的时候没有小括号，这里只是为了演示。 示例： 单行代码 1`#include &lt;iostream&gt;` 代码块 12345678(```)#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; printf(&quot;Hello world~!&quot;); return 0;&#125;(```) 效果： 单行代码#include &lt;iostream&gt; 代码块123456#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; printf(&quot;Hello world~!&quot;); return 0; &#125; 代办事项代办事项和清单，在Ｍarkdown中，你住需要在代办的事项文本或者清单文本前面加上-[]即可． 语法： 表示未完成 表示已经完成 试例：123- [x] 分析需求- [ ] 研发- [ ] 测试 效果: 分析需求 研发 测试 转义符在markdown文档一般无法直接中输出被用于传唤格式的符号本身，通常需要用到转义符，也就是\来协助:如果要显示*,则可使用如下方式:1/* 常用的转义符号有：123456789101112\ 反斜线` 反引号\* 星号\_ 下划线&#123;&#125; 花括号[] 方括号() 圆括号# 井号+ 加号- 减号（连字符）. 句点! 感叹号 缩进在没一行开头的时候输入下面的代码，然后跟着输入文本即可．注意分号！语法:半角空格: &amp;ensp; 或 &amp;#8194;全角空格: &amp;emsp; 或 &amp;#8195;不换行空格: &amp;nbsp; 或 &amp;#160;示例:1234正常文本&amp;ensp;&amp;#8194;半角空格缩进&amp;emsp;&amp;#8195;全角空格&amp;nbsp;&amp;#160;不换行空格 效果:正常文本&ensp;&#8194;半角空格缩进&emsp;&#8195;全角空格&nbsp;&#160;不换行空格 参考网址参考：https://www.jianshu.com/p/b421cc723da5https://www.jianshu.com/p/191d1e21f7edhttps://www.jianshu.com/p/335db5716248https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Mkdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
